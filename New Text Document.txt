// =======================================================
// MicroJava Large Test Program
// Purpose: Stress test for lexer, parser, semantic analyzer
// Lines: 600+
// =======================================================

program BigMicroJavaTest;

// =======================================================
// GLOBAL CONSTANTS
// =======================================================

const int MAX = 100;
const int MIN = 0;
const int TRUE = 1;
const int FALSE = 0;

// =======================================================
// GLOBAL VARIABLES
// =======================================================

int globalCounter;
int errorCount;
int successCount;

int numbers[MAX];
int squares[MAX];
int cubes[MAX];

// =======================================================
// UTILITY PROCEDURES
// =======================================================

void resetGlobals() {
    globalCounter = 0;
    errorCount = 0;
    successCount = 0;
}

void incrementGlobal() {
    globalCounter = globalCounter + 1;
}

void logSuccess() {
    successCount = successCount + 1;
}

void logError() {
    errorCount = errorCount + 1;
}

// =======================================================
// ARRAY INITIALIZATION
// =======================================================

void initNumbers() {
    int i;
    i = 0;
    while (i < MAX) {
        numbers[i] = i;
        i = i + 1;
    }
}

void initSquares() {
    int i;
    i = 0;
    while (i < MAX) {
        squares[i] = numbers[i] * numbers[i];
        i = i + 1;
    }
}

void initCubes() {
    int i;
    i = 0;
    while (i < MAX) {
        cubes[i] = numbers[i] * numbers[i] * numbers[i];
        i = i + 1;
    }
}

// =======================================================
// VALIDATION PROCEDURES
// =======================================================

int isEven(int x) {
    if ((x % 2) == 0) {
        return TRUE;
    } else {
        return FALSE;
    }
}

int isOdd(int x) {
    if ((x % 2) != 0) {
        return TRUE;
    } else {
        return FALSE;
    }
}

int greaterThanTen(int x) {
    if (x > 10) {
        return TRUE;
    } else {
        return FALSE;
    }
}

// =======================================================
// COMPLEX COMPUTATIONS
// =======================================================

int factorial(int n) {
    int result;
    int i;
    result = 1;
    i = 1;
    while (i <= n) {
        result = result * i;
        i = i + 1;
    }
    return result;
}

int fibonacci(int n) {
    if (n <= 1) {
        return n;
    } else {
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

// =======================================================
// ARRAY TESTS
// =======================================================

void testEvenNumbers() {
    int i;
    i = 0;
    while (i < MAX) {
        if (isEven(numbers[i]) == TRUE) {
            logSuccess();
        } else {
            logError();
        }
        i = i + 1;
    }
}

void testOddNumbers() {
    int i;
    i = 0;
    while (i < MAX) {
        if (isOdd(numbers[i]) == TRUE) {
            logSuccess();
        } else {
            logError();
        }
        i = i + 1;
    }
}

void testSquares() {
    int i;
    i = 0;
    while (i < MAX) {
        if (squares[i] == (numbers[i] * numbers[i])) {
            logSuccess();
        } else {
            logError();
        }
        i = i + 1;
    }
}

void testCubes() {
    int i;
    i = 0;
    while (i < MAX) {
        if (cubes[i] == (numbers[i] * numbers[i] * numbers[i])) {
            logSuccess();
        } else {
            logError();
        }
        i = i + 1;
    }
}

// =======================================================
// STRESS PROCEDURES (REPETITIVE BY DESIGN)
// =======================================================

void stressLoopA() {
    int i;
    i = 0;
    while (i < 50) {
        incrementGlobal();
        i = i + 1;
    }
}

void stressLoopB() {
    int i;
    i = 0;
    while (i < 50) {
        incrementGlobal();
        i = i + 1;
    }
}

void stressLoopC() {
    int i;
    i = 0;
    while (i < 50) {
        incrementGlobal();
        i = i + 1;
    }
}

void stressLoopD() {
    int i;
    i = 0;
    while (i < 50) {
        incrementGlobal();
        i = i + 1;
    }
}

void stressLoopE() {
    int i;
    i = 0;
    while (i < 50) {
        incrementGlobal();
        i = i + 1;
    }
}

// =======================================================
// NESTED CONTROL FLOW TESTS
// =======================================================

void nestedConditions() {
    int i;
    i = 0;
    while (i < 20) {
        if (i < 5) {
            logSuccess();
        } else {
            if (i < 10) {
                logSuccess();
            } else {
                if (i < 15) {
                    logSuccess();
                } else {
                    logError();
                }
            }
        }
        i = i + 1;
    }
}

// =======================================================
// FUNCTION CALL CHAIN TEST
// =======================================================

void callChainA() { callChainB(); }
void callChainB() { callChainC(); }
void callChainC() { callChainD(); }
void callChainD() { callChainE(); }
void callChainE() { incrementGlobal(); }

// =======================================================
// MAIN PROGRAM
// =======================================================

void main() {

    resetGlobals();

    initNumbers();
    initSquares();
    initCubes();

    testEvenNumbers();
    testOddNumbers();
    testSquares();
    testCubes();

    stressLoopA();
    stressLoopB();
    stressLoopC();
    stressLoopD();
    stressLoopE();

    nestedConditions();

    callChainA();

    // Factorial tests
    factorial(5);
    factorial(6);
    factorial(7);

    // Fibonacci tests
    fibonacci(5);
    fibonacci(6);
    fibonacci(7);

    // Final increment
    incrementGlobal();
}

// =======================================================
// END OF FILE
// =======================================================
